<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<STYLE>
h2 { font-size: 12pt }
ol { font-size: 10pt }
pre { font-size: 11pt }
</STYLE>
<TITLE>UW-Madison ACM Reference 2014</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<H1>UW-Madison ACM Reference 2014</H1>
<H2>Graph</H2>
<OL>
<LI><A HREF="#file1">Maximum matching (C++)</A>
<LI><A HREF="#file2">Maximum flow (C++)</A>
<LI><A HREF="#file3">Strongly connected components (C++)</A>
<LI><A HREF="#file4">Minimum spanning tree (C++)</A>
<LI><A HREF="#file5">Suurballe (C++)</A>
<LI><A HREF="#file6">Dijkstra (C++)</A>
<LI><A HREF="#file7">Bellman ford (C++)</A>
<LI><A HREF="#file8">Articulation point (C++)</A>
<LI><A HREF="#file9">Floyd (C++)</A>
</OL>
<H2>Geometry and Num</H2>
<OL>
<LI><A HREF="#file10">Euclid (C++)</A>
<LI><A HREF="#file11">Geometry (C++)</A>
<LI><A HREF="#file12">Convex hull (C++)</A>
<LI><A HREF="#file13">Combination (C++)</A>
<LI><A HREF="#file14">Gauss jordan (C++)</A>
</OL>
<H2>String manipulation</H2>
<OL>
<LI><A HREF="#file15">Knut morris pratt (C++)</A>
<LI><A HREF="#file16">LIS (C++)</A>
<LI><A HREF="#file17">Suffix array (C++)</A>
</OL>
<HR>
<H2><A NAME="file1">Maximum matching (C++)</A></H2>
<PRE>
<I><FONT COLOR="#B22222">// This code performs maximum bipartite matching.
</FONT></I><I><FONT COLOR="#B22222">// It has a heuristic that will give excellent performance on complete graphs
</FONT></I><I><FONT COLOR="#B22222">// where rows &lt;= columns.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT: w[i][j] = cost from row node i and column node j or NO_EDGE
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT: mr[i] = assignment for row node i or -1 if unassigned
</FONT></I><I><FONT COLOR="#B22222">//           mc[j] = assignment for column node j or -1 if unassigned
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   BipartiteMatching returns the number of matches made.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Contributed by Andy Lutomirski.
</FONT></I>
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> NO_EDGE = -(1&lt;&lt;30);  <I><FONT COLOR="#B22222">// Or any other value.
</FONT></I>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">FindMatch</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;mr, VI &amp;mc, VI &amp;seen)
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (seen[i])
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
  seen[i] = true;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; w[i].size(); j++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j] != NO_EDGE &amp;&amp; mc[j] &lt; 0) {
      mr[i] = j;
      mc[j] = i;
      <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; w[i].size(); j++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j] != NO_EDGE &amp;&amp; mr[i] != j) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (mc[j] &lt; 0 || FindMatch(mc[j], w, mr, mc, seen)) {
	mr[i] = j;
	mc[j] = i;
	<B><FONT COLOR="#A020F0">return</FONT></B> true;
      }
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">BipartiteMatching</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;mr, VI &amp;mc)
{
  mr = VI (w.size(), -1);
  mc = VI(w[0].size(), -1);
  VI seen(w.size());

  <B><FONT COLOR="#228B22">int</FONT></B> ct = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; w.size(); i++)
    {
      fill(seen.begin(), seen.end(), 0);
      <B><FONT COLOR="#A020F0">if</FONT></B> (FindMatch(i, w, mr, mc, seen)) ct++;
    }
  <B><FONT COLOR="#A020F0">return</FONT></B> ct;
}
</PRE>
<HR>
<H2><A NAME="file2">Maximum flow (C++)</A></H2>
<PRE>
<I><FONT COLOR="#B22222">/****************
 * Maximum flow * (Dinic's on an adjacency list + matrix)
 ****************
 * Takes a weighted directed graph of edge capacities as an adjacency 
 * matrix 'cap' and returns the maximum flow from s to t.
 *
 * PARAMETERS:
 *      - cap (global): adjacency matrix where cap[u][v] is the capacity
 *          of the edge u-&gt;v. cap[u][v] is 0 for non-existent edges.
 *      - n: the number of vertices ([0, n-1] are considered as vertices).
 *      - s: source vertex.
 *      - t: sink.
 * RETURNS:
 *      - the flow
 *      - prev contains the minimum cut. If prev[v] == -1, then v is not
 *          reachable from s; otherwise, it is reachable.
 * RUNNING TIME:
 *      - O(n^3)
 **/</FONT></I>

<I><FONT COLOR="#B22222">// the maximum number of vertices
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">NN</FONT> 1024
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 2000000000;

<I><FONT COLOR="#B22222">// adjacency matrix (fill this up)
</FONT></I><I><FONT COLOR="#B22222">// If you fill adj[][] yourself, make sure to include both u-&gt;v and v-&gt;u.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> cap[NN][NN], deg[NN], adj[NN][NN];

<I><FONT COLOR="#B22222">// BFS stuff
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> q[NN], prev[NN];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dinic</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t ) {
    <B><FONT COLOR="#228B22">int</FONT></B> flow = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B>( true ) {
        memset( prev, -1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>( prev ) );
        <B><FONT COLOR="#228B22">int</FONT></B> qf = 0, qb = 0;
        prev[q[qb++] = s] = -2;
        <B><FONT COLOR="#A020F0">while</FONT></B> ( qb &gt; qf &amp;&amp; prev[t] == -1 )
            <B><FONT COLOR="#A020F0">for</FONT></B> ( <B><FONT COLOR="#228B22">int</FONT></B> u = q[qf++], i = 0, v; i &lt; deg[u]; i++ )
                <B><FONT COLOR="#A020F0">if</FONT></B>( prev[v = adj[u][i]] == -1 &amp;&amp; cap[u][v] )
                    prev[q[qb++] = v] = u;
        <B><FONT COLOR="#A020F0">if</FONT></B> ( prev[t] == -1 ) <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">for</FONT></B> ( <B><FONT COLOR="#228B22">int</FONT></B> z = 0; z &lt; n; z++ ) <B><FONT COLOR="#A020F0">if</FONT></B>( cap[z][t] &amp;&amp; prev[z] != -1 ) {
            <B><FONT COLOR="#228B22">int</FONT></B> bot = cap[z][t];
            <B><FONT COLOR="#A020F0">for</FONT></B> ( <B><FONT COLOR="#228B22">int</FONT></B> v = z, u = prev[v]; u &gt;= 0; v = u, u = prev[v] )
                bot = min(bot, cap[u][v]);
            <B><FONT COLOR="#A020F0">if</FONT></B> ( !bot ) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            cap[z][t] -= bot;
            cap[t][z] += bot;
            <B><FONT COLOR="#A020F0">for</FONT></B> ( <B><FONT COLOR="#228B22">int</FONT></B> v = z, u = prev[v]; u &gt;= 0; v = u, u = prev[v] ) {
                cap[u][v] -= bot;
                cap[v][u] += bot;
            }
            flow += bot;
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> flow;
}

<I><FONT COLOR="#B22222">//----------------- EXAMPLE USAGE -----------------
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <I><FONT COLOR="#B22222">// read a graph into cap[][]
</FONT></I>    memset( cap, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>( cap ) );
    <B><FONT COLOR="#228B22">int</FONT></B> n, s, t, m;
    scanf( <B><FONT COLOR="#BC8F8F">&quot; %d %d %d %d&quot;</FONT></B>, &amp;n, &amp;s, &amp;t, &amp;m );
    <B><FONT COLOR="#A020F0">while</FONT></B>( m-- ) {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v, c; scanf( <B><FONT COLOR="#BC8F8F">&quot; %d %d %d&quot;</FONT></B>, &amp;u, &amp;v, &amp;c );
        cap[u][v] = c;
    }

    <I><FONT COLOR="#B22222">// init the adjacency list adj[][] from cap[][]
</FONT></I>    memset( deg, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>( deg ) );
    <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> u = 0; u &lt; n; u++ )
        <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> v = 0; v &lt; n; v++ ) <B><FONT COLOR="#A020F0">if</FONT></B>( cap[u][v] || cap[v][u] )
            adj[u][deg[u]++] = v;

    printf( <B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, dinic( n, s, t ) );
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<H2><A NAME="file3">Strongly connected components (C++)</A></H2>
<PRE>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">mp</FONT> make_pair
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">pb</FONT> push_back
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXV</FONT> 100
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXE</FONT> 100
<B><FONT COLOR="#228B22">struct</FONT></B> edge {
  <B><FONT COLOR="#228B22">int</FONT></B> e, 
  nxt;
};

<B><FONT COLOR="#228B22">int</FONT></B> V, E;
edge e[MAXE], er[MAXE];
<B><FONT COLOR="#228B22">int</FONT></B> sp[MAXV], spr[MAXV];
<B><FONT COLOR="#228B22">int</FONT></B> group_cnt, group_num[MAXV];
<B><FONT COLOR="#228B22">bool</FONT></B> v[MAXV];
<B><FONT COLOR="#228B22">int</FONT></B> stk[MAXV];

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">fill_forward</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) {
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  v[x] = true;
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = sp[x]; i; i = e[i].nxt) 
    <B><FONT COLOR="#A020F0">if</FONT></B>(!v[e[i].e]) 
      fill_forward(e[i].e);
  stk[++stk[0]] = x;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">fill_backward</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) {
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  v[x] = false;
  group_num[x] = group_cnt;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i = spr[x]; i; i = er[i].nxt) 
    <B><FONT COLOR="#A020F0">if</FONT></B>(v[er[i].e]) 
      fill_backward(er[i].e);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">add_edge</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> v1, <B><FONT COLOR="#228B22">int</FONT></B> v2) {<I><FONT COLOR="#B22222">//add edge v1-&gt;v2
</FONT></I>  e[++E].e = v2; 
  e[E].nxt = sp[v1]; 
  sp[v1] = E;
  er[E].e = v1; 
  er[E].nxt = spr[v2]; 
  spr[v2] = E;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">SCC</FONT></B>() {
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  stk[0] = 0;
  memset(v, false, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(v));
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 1; i &lt;= V;i++) 
    <B><FONT COLOR="#A020F0">if</FONT></B>(!v[i]) 
      fill_forward(i);
  group_cnt = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = stk[0];i &gt;= 1;i--) 
    <B><FONT COLOR="#A020F0">if</FONT></B>(v[stk[i]]) {
      group_cnt++; 
      fill_backward(stk[i]);
    }
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">int</FONT></B> t;
  scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;t);
  <B><FONT COLOR="#A020F0">while</FONT></B> (t--) {
    memset(stk, -1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(stk));
    memset(sp, -1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(sp));
    memset(spr, -1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(spr));
    <B><FONT COLOR="#228B22">int</FONT></B> m;
    E = 0;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;V, &amp;m);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
      <B><FONT COLOR="#228B22">int</FONT></B> x, y;
      scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;x, &amp;y);
      add_edge(x, y);
    }
    SCC();
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, group_cnt);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= V; i++)
      printf(<B><FONT COLOR="#BC8F8F">&quot;%d stays in group %d\n&quot;</FONT></B>, i, group_num[i]);
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
  }
}
</PRE>
<HR>
<H2><A NAME="file4">Minimum spanning tree (C++)</A></H2>
<PRE>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">mp</FONT> make_pair
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">pb</FONT> push_back
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">Max</FONT> 1000100
using namespace std;
vector&lt; pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; &gt;v, mst;
<B><FONT COLOR="#228B22">int</FONT></B> parent[Max], rank[Max];

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">makeSet</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
		parent[i] = i,
		rank[i] = 0;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">find</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (x != parent[x])
		parent[x] = find(parent[x]);
	<B><FONT COLOR="#A020F0">return</FONT></B> parent[x];
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">merge</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) {
	<B><FONT COLOR="#228B22">int</FONT></B> Px = find(x);
	<B><FONT COLOR="#228B22">int</FONT></B> Py = find(y);

	<B><FONT COLOR="#A020F0">if</FONT></B> (rank[Px] &gt; rank[Py])
		parent[Py] = Px;
	<B><FONT COLOR="#A020F0">else</FONT></B>
		parent[Px] = Py;

	<B><FONT COLOR="#A020F0">if</FONT></B> (rank[Px] == rank[Py])
		++rank[Py];

}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> *argv[]) {
    <I><FONT COLOR="#B22222">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
</FONT></I>    <I><FONT COLOR="#B22222">//freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> n, m;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;n, &amp;m);
    makeSet(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
    	<B><FONT COLOR="#228B22">int</FONT></B> x, y, w;
    	scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%d&quot;</FONT></B>, &amp;x, &amp;y, &amp;w);
    	x--, --y;
    	v.pb(mp(w, mp(x, y)));
    }
    sort(v.begin(), v.end());

    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ret = 0ll;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, k = 0; k &lt; n-1; i++) {
    	<B><FONT COLOR="#228B22">int</FONT></B> x = find(v[i].second.first);
    	<B><FONT COLOR="#228B22">int</FONT></B> y = find(v[i].second.second);
    	<B><FONT COLOR="#A020F0">if</FONT></B> (x != y) {
    		mst.pb(v[i]);
    		ret += 1ll*v[i].first;
    		merge(x, y);
    		k++;
    	}
    }

    printf(<B><FONT COLOR="#BC8F8F">&quot;%lld\n&quot;</FONT></B>, ret);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<H2><A NAME="file5">Suurballe (C++)</A></H2>
<PRE>
<I><FONT COLOR="#B22222">// Suurballe's algorithm.
</FONT></I><I><FONT COLOR="#B22222">// finds smallest possible sum of weight of two disjoint paths from s to t.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;climits&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cctype&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;

<I><FONT COLOR="#B22222">//XXX XXX define me
</FONT></I><I><FONT COLOR="#B22222">//#define PRINT_PATH
</FONT></I><I><FONT COLOR="#B22222">//XXX XXX define me
</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAX_E</FONT> 99999 // should be 2*actual maximum
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAX_V</FONT> 9999

<B><FONT COLOR="#228B22">int</FONT></B> e_from[MAX_E], e_to[MAX_E], e_cap[MAX_E], e_flow[MAX_E], e_cost[MAX_E], e_dual[MAX_E];
VVI edges;
<B><FONT COLOR="#228B22">int</FONT></B> s, t;

<B><FONT COLOR="#228B22">int</FONT></B> back_e[MAX_V];
<B><FONT COLOR="#228B22">int</FONT></B> cost[MAX_V];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">augment</FONT></B>() {
    memset(cost, 0x10, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(cost));
    priority_queue&lt;PII&gt; q;
    cost[s] = 0;
    q.push(make_pair(0,s));
    <B><FONT COLOR="#A020F0">while</FONT></B>( q.size() &gt; 0 ) {
        PII cur_p = q.top(); q.pop();
        <B><FONT COLOR="#228B22">int</FONT></B> cur = cur_p.second;
        <B><FONT COLOR="#228B22">int</FONT></B> curcost = -cur_p.first;
        <B><FONT COLOR="#A020F0">if</FONT></B>( cost[cur] &lt; curcost ) { <B><FONT COLOR="#A020F0">continue</FONT></B>; }
        <B><FONT COLOR="#A020F0">if</FONT></B>( cur == t ) {
            <I><FONT COLOR="#B22222">// augment path
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> v = t;
            #ifdef PRINT_PATH
            VI path; path.push_back(v/2);
            #endif
            <B><FONT COLOR="#A020F0">while</FONT></B>( v != s ) {
                <B><FONT COLOR="#228B22">int</FONT></B> e = back_e[v];
                <B><FONT COLOR="#228B22">int</FONT></B> d = e_dual[e];
                e_flow[e] += 1;
                e_flow[d] -= 1;
                v = e_from[e];
                #ifdef PRINT_PATH
                <B><FONT COLOR="#A020F0">if</FONT></B>( v/2 != *path.rbegin() ) { path.push_back(e_cost[e]); path.push_back(v/2); }
                #endif
            }
            #ifdef PRINT_PATH
            reverse(path.begin(), path.end()); printf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, path[0]);
            <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; path.size(); i += 2 ) {
              printf(<B><FONT COLOR="#BC8F8F">&quot; --[%d]--&gt; %d&quot;</FONT></B>, path[i], path[i+1]);
            } puts(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
            #endif
            <B><FONT COLOR="#A020F0">return</FONT></B> curcost;
        }
        <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; edges[cur].size(); ++i ) {
            <B><FONT COLOR="#228B22">int</FONT></B> e = edges[cur][i];
            <B><FONT COLOR="#A020F0">if</FONT></B>( e_flow[e] &gt;= e_cap[e] ) { <B><FONT COLOR="#A020F0">continue</FONT></B>; }
            <B><FONT COLOR="#228B22">int</FONT></B> next = e_to[e];
            <B><FONT COLOR="#228B22">int</FONT></B> nextcost = curcost + e_cost[e];
            <B><FONT COLOR="#A020F0">if</FONT></B>( cost[next] &gt; nextcost ) {
                back_e[next] = e;
                cost[next] = nextcost;
                q.push(make_pair(-nextcost, next));
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">solve</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> v, e; <B><FONT COLOR="#A020F0">if</FONT></B>( scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;v, &amp;e) != 2 ) exit(0);
    edges = VVI(2*v,VI());
    <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v; ++i ) {
        <B><FONT COLOR="#228B22">int</FONT></B> idx = 2*i;
        e_from[idx] = 2*i;
        e_to[idx] = 2*i+1;
        e_cost[idx] = e_cost[idx+1] = 0;
        e_from[idx+1] = e_to[idx];
        e_to[idx+1] = e_from[idx];
        e_cap[idx] = e_cap[idx+1] = 1;
        e_flow[idx] = 0; e_flow[idx+1] = 1;
        e_dual[idx] = idx+1; e_dual[idx+1] = idx;
        edges[e_from[idx]].push_back(idx);
        edges[e_from[idx+1]].push_back(idx+1);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; e; ++i ) {
        <B><FONT COLOR="#228B22">int</FONT></B> idx = 2*i+2*v;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%d&quot;</FONT></B>, &amp;e_from[idx], &amp;e_to[idx], &amp;e_cost[idx]);
        e_from[idx] -= 1; e_to[idx] -= 1;
        e_from[idx] *= 2; e_to[idx] *= 2;
        e_from[idx] += 1;
        e_from[idx+1] = e_to[idx];
        e_to[idx+1] = e_from[idx];
        e_cost[idx+1] = -e_cost[idx];
        e_cap[idx] = e_cap[idx+1] = 1;
        e_flow[idx] = 0; e_flow[idx+1] = 1;
        e_dual[idx] = idx+1; e_dual[idx+1] = idx;
        edges[e_from[idx]].push_back(idx);
        edges[e_from[idx+1]].push_back(idx+1);
    }
    s = 1; t = 2*(v-1);
    <B><FONT COLOR="#228B22">int</FONT></B> total = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>( <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 2; ++i ) {
        total += augment();
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B> , total);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#A020F0">while</FONT></B>( true ) solve();
}
</PRE>
<HR>
<H2><A NAME="file6">Dijkstra (C++)</A></H2>
<PRE>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">mp</FONT> make_pair
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">pb</FONT> push_back
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">Pair</FONT> pair&lt;int, int&gt; // V W
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">xx</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">yy</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">Max</FONT> 100010
<B><FONT COLOR="#228B22">struct</FONT></B> cmp {
	<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>() (<B><FONT COLOR="#228B22">const</FONT></B> Pair &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> Pair &amp;b) <B><FONT COLOR="#228B22">const</FONT></B> {
		<B><FONT COLOR="#A020F0">return</FONT></B> a.yy &gt; b.yy;
	}
};
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> INF = 12345678987654321LL;
priority_queue&lt; Pair, vector&lt; Pair &gt;, cmp&gt; q;
vector&lt; Pair &gt;v[Max];
<B><FONT COLOR="#228B22">int</FONT></B> n, m;
<B><FONT COLOR="#228B22">bool</FONT></B> used[Max];
<B><FONT COLOR="#228B22">int</FONT></B> uu[Max];
<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> d[Max];
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (i == 0) {
		printf(<B><FONT COLOR="#BC8F8F">&quot;1 &quot;</FONT></B>);
		<B><FONT COLOR="#A020F0">return</FONT></B>;
	}
	dfs(uu[i]);
	printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, i+1);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> *argv[]) {
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;n, &amp;m);
    <B><FONT COLOR="#A020F0">while</FONT></B> (m--) {
    	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
    	scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%d&quot;</FONT></B>, &amp;a, &amp;b, &amp;w);
    	a--, --b;
    	v[a].pb(mp(b, w));
    	v[b].pb(mp(a, w));
    }
    uu[0] = 0; <I><FONT COLOR="#B22222">//from vertex 0.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
    	d[i] = INF;
    d[0] = 0ll;
    q.push(mp(0, 0));
    <B><FONT COLOR="#A020F0">while</FONT></B> (q.size()) {
    	<B><FONT COLOR="#228B22">int</FONT></B> u = q.top().xx;
    	q.pop();
    	<B><FONT COLOR="#228B22">int</FONT></B> sz = v[u].size();
    	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
    		<B><FONT COLOR="#228B22">int</FONT></B> vv = v[u][i].xx;
    		<B><FONT COLOR="#228B22">int</FONT></B> ww = v[u][i].yy;
    		
    		<B><FONT COLOR="#A020F0">if</FONT></B>(!used[vv] &amp;&amp; d[u]+ww &lt; d[vv]) {
    			d[vv] = d[u]+ww;
    			q.push(mp(vv, d[vv]));
    			uu[vv] = u;
    		}

    	}
    	used[u] = 1;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (d[n-1] == INF)
    	printf(<B><FONT COLOR="#BC8F8F">&quot;-1\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">else</FONT></B>
    	dfs(n-1);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<H2><A NAME="file7">Bellman ford (C++)</A></H2>
<PRE>
<I><FONT COLOR="#B22222">// This function runs the Bellman-Ford algorithm for single source
</FONT></I><I><FONT COLOR="#B22222">// shortest paths with negative edge weights.  The function returns
</FONT></I><I><FONT COLOR="#B22222">// false if a negative weight cycle is detected.  Otherwise, the
</FONT></I><I><FONT COLOR="#B22222">// function returns true and dist[i] is the length of the shortest
</FONT></I><I><FONT COLOR="#B22222">// path from start to i.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   start, w[i][j] = cost of edge from i to j
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  dist[i] = min weight path from start to i
</FONT></I><I><FONT COLOR="#B22222">//            prev[i] = previous node on the best path from the
</FONT></I><I><FONT COLOR="#B22222">//                      start node   
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> TYPE;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;TYPE&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">BellmanFord</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> VVT &amp;w, VT &amp;dist, VI &amp;prev, <B><FONT COLOR="#228B22">int</FONT></B> start){
  <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
  prev = VI(n, -1);
  dist = VT(n, 1000000000);
  dist[start] = 0;

  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++){
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++){
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++){
	<B><FONT COLOR="#A020F0">if</FONT></B> (dist[j] &gt; dist[i] + w[i][j]){
	  <B><FONT COLOR="#A020F0">if</FONT></B> (k == n-1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
	  dist[j] = dist[i] + w[i][j];
	  prev[j] = i;
	}	  
      }
    }
  }

  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
</PRE>
<HR>
<H2><A NAME="file8">Articulation point (C++)</A></H2>
<PRE>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">N</FONT> 400001
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">pb</FONT> push_back
<B><FONT COLOR="#228B22">int</FONT></B> num[N] = {0}, low[N] = {0};
<B><FONT COLOR="#228B22">int</FONT></B> visit[N] = {0};
<B><FONT COLOR="#228B22">int</FONT></B> parentt[N] = {0}; 
<B><FONT COLOR="#228B22">int</FONT></B> V, E;        
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; ad[N];
<B><FONT COLOR="#228B22">int</FONT></B> art[N] = {0};
<B><FONT COLOR="#228B22">int</FONT></B> counter;
<B><FONT COLOR="#228B22">int</FONT></B> root, child = 0;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">findartd</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> ver) {
    visit[ver] = 1;
	  low[ver] = num[ver] = counter++;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;::iterator it;
    <B><FONT COLOR="#A020F0">for</FONT></B> (it = ad[ver].begin(); it &lt; ad[ver].end(); it++)
         <B><FONT COLOR="#A020F0">if</FONT></B> (visit[*it] == 0) {
             <B><FONT COLOR="#A020F0">if</FONT></B> (root == ver)
                 child++;
             parentt[*it] = ver;
             <B><FONT COLOR="#228B22">int</FONT></B> tm = *it;
             findartd(tm);
	           <B><FONT COLOR="#A020F0">if</FONT></B> (low[*it] &gt;= num[ver]) {

                 <B><FONT COLOR="#A020F0">if</FONT></B> (art[ver] == 0 &amp;&amp; root != ver) 
                     art[ver] = 1;

             }
             low[ver]=min(low[ver],low[*it]);	
             
          } <B><FONT COLOR="#A020F0">else</FONT></B> 
               <B><FONT COLOR="#A020F0">if</FONT></B> (parentt[ver] != *it)
                   low[ver] = min(low[ver], num[*it]);	
} 
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<B><FONT COLOR="#A020F0">while</FONT></B> (true) {
		scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;V, &amp;E);
		<B><FONT COLOR="#A020F0">if</FONT></B>(V == 0 &amp;&amp; E == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; E; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> s, t;	
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;s, &amp;t);
        ad[s].pb(t);
        ad[t].pb(s);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; V; i++) 
        <B><FONT COLOR="#A020F0">if</FONT></B> (!visit[i]) {
            counter = 1;
            child = 0;
            root = i;
            findartd(root);
            <B><FONT COLOR="#A020F0">if</FONT></B> (child &gt; 1) art[root] = 1;
        }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; V; i++)
         <B><FONT COLOR="#A020F0">if</FONT></B>(art[i] == 1)
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, i); 
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; V; i++) ad[i].clear();
    memset(num,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(num));
	  memset(visit,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(visit));
	  memset(parentt,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(parentt));
    memset(art,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(art));
	  memset(low,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(low));

  }<I><FONT COLOR="#B22222">//while(true)..
</FONT></I> 
<B><FONT COLOR="#A020F0">return</FONT></B> 0; }
</PRE>
<HR>
<H2><A NAME="file9">Floyd (C++)</A></H2>
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> TYPE;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;TYPE&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">FloydWarshall</FONT></B> (VVT &amp;w, VVI &amp;prev){
  <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
  prev = VVI (n, VI(n, -1));
  
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++){
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++){
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++){
      	<B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j] &gt; w[i][k] + w[k][j]){
      	  w[i][j] = w[i][k] + w[k][j];
      	  prev[i][j] = k;
      	}
      }
    }
  }
  <I><FONT COLOR="#B22222">// check for negative weight cycles
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][i] &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">return</FONT></B> true;    
}
</PRE>
<HR>
<H2><A NAME="file10">Euclid (C++)</A></H2>
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<I><FONT COLOR="#B22222">// return a % b (positive value)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
  <B><FONT COLOR="#A020F0">return</FONT></B> ((a%b)+b)%b;
}
<I><FONT COLOR="#B22222">// computes gcd(a,b)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">gcd</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
  <B><FONT COLOR="#228B22">int</FONT></B> tmp;
  <B><FONT COLOR="#A020F0">while</FONT></B>(b){a%=b; tmp=a; a=b; b=tmp;}
  <B><FONT COLOR="#A020F0">return</FONT></B> a;
}
<I><FONT COLOR="#B22222">// computes lcm(a,b)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lcm</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
  <B><FONT COLOR="#A020F0">return</FONT></B> a/gcd(a,b)*b;
}
<I><FONT COLOR="#B22222">// returns d = gcd(a,b); finds x,y such that d = ax + by
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">extended_euclid</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {  
  <B><FONT COLOR="#228B22">int</FONT></B> xx = y = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> yy = x = 1;
  <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
    <B><FONT COLOR="#228B22">int</FONT></B> q = a/b;
    <B><FONT COLOR="#228B22">int</FONT></B> t = b; b = a%b; a = t;
    t = xx; xx = x-q*xx; x = t;
    t = yy; yy = y-q*yy; y = t;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> a;
}
<I><FONT COLOR="#B22222">// finds all solutions to ax = b (mod n)
</FONT></I>VI <B><FONT COLOR="#0000FF">modular_linear_equation_solver</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> n) {
  <B><FONT COLOR="#228B22">int</FONT></B> x, y;
  VI solutions;
  <B><FONT COLOR="#228B22">int</FONT></B> d = extended_euclid(a, n, x, y);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!(b%d)) {
    x = mod (x*(b/d), n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; d; i++)
      solutions.push_back(mod(x + i*(n/d), n));
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> solutions;
}
<I><FONT COLOR="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod_inverse</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> n) {
  <B><FONT COLOR="#228B22">int</FONT></B> x, y;
  <B><FONT COLOR="#228B22">int</FONT></B> d = extended_euclid(a, n, x, y);
  <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
  <B><FONT COLOR="#A020F0">return</FONT></B> mod(x,n);
}
<I><FONT COLOR="#B22222">// Chinese remainder theorem (special case): find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % x = a, z % y = b.  Here, z is unique modulo M = lcm(x,y).
</FONT></I><I><FONT COLOR="#B22222">// Return (z,M).  On failure, M = -1.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> y, <B><FONT COLOR="#228B22">int</FONT></B> b) {
  <B><FONT COLOR="#228B22">int</FONT></B> s, t;
  <B><FONT COLOR="#228B22">int</FONT></B> d = extended_euclid(x, y, s, t);
  <B><FONT COLOR="#A020F0">if</FONT></B> (a%d != b%d) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(0, -1);
  <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(mod(s*b*x+t*a*y,x*y)/d, x*y/d);
}
<I><FONT COLOR="#B22222">// Chinese remainder theorem: find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % x[i] = a[i] for all i.  Note that the solution is
</FONT></I><I><FONT COLOR="#B22222">// unique modulo M = lcm_i (x[i]).  Return (z,M).  On 
</FONT></I><I><FONT COLOR="#B22222">// failure, M = -1.  Note that we do not require the a[i]'s
</FONT></I><I><FONT COLOR="#B22222">// to be relatively prime.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> VI &amp;a) {
  PII ret = make_pair(a[0], x[0]);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; x.size(); i++) {
    ret = chinese_remainder_theorem(ret.second, ret.first, x[i], a[i]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ret.second == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// computes x and y such that ax + by = c; on failure, x = y =-1
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">linear_diophantine</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> c, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {
  <B><FONT COLOR="#228B22">int</FONT></B> d = gcd(a,b);
  <B><FONT COLOR="#A020F0">if</FONT></B> (c%d) {
    x = y = -1;
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    x = c/d * mod_inverse(a/d, b/d);
    y = (c-a*x)/b;
  }
}
</PRE>
<HR>
<H2><A NAME="file11">Geometry (C++)</A></H2>
<PRE>
<B><FONT COLOR="#228B22">double</FONT></B> INF = 1e100;
<B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-12;

<B><FONT COLOR="#228B22">struct</FONT></B> PT { 
  <B><FONT COLOR="#228B22">double</FONT></B> x, y; 
  PT() {}
  PT(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y) : x(x), y(y) {}
  PT(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) : x(p.x), y(p.y)    {}
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> + (<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p)  <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x+p.x, y+p.y); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> - (<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p)  <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x-p.x, y-p.y); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> * (<B><FONT COLOR="#228B22">double</FONT></B> c)     <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x*c,   y*c  ); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> / (<B><FONT COLOR="#228B22">double</FONT></B> c)     <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x/c,   y/c  ); }
};

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dot</FONT></B>(PT p, PT q)     { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.x+p.y*q.y; }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dist2</FONT></B>(PT p, PT q)   { <B><FONT COLOR="#A020F0">return</FONT></B> dot(p-q,p-q); }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(PT p, PT q)   { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.y-p.y*q.x; }
ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;os, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) {
  os &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; p.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B> &lt;&lt; p.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>; 
}

<I><FONT COLOR="#B22222">// rotate a point CCW or CW around the origin
</FONT></I>PT <B><FONT COLOR="#0000FF">RotateCCW90</FONT></B>(PT p)   { <B><FONT COLOR="#A020F0">return</FONT></B> PT(-p.y,p.x); }
PT <B><FONT COLOR="#0000FF">RotateCW90</FONT></B>(PT p)    { <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.y,-p.x); }
PT <B><FONT COLOR="#0000FF">RotateCCW</FONT></B>(PT p, <B><FONT COLOR="#228B22">double</FONT></B> t) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); 
}

<I><FONT COLOR="#B22222">// project point c onto line through a and b
</FONT></I><I><FONT COLOR="#B22222">// assuming a != b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointLine</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
}

<I><FONT COLOR="#B22222">// project point c onto line segment through a and b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointSegment</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#228B22">double</FONT></B> r = dot(b-a,b-a);
  <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(r) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> a;
  r = dot(c-a, b-a)/r;
  <B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> a;
  <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> b;
  <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*r;
}

<I><FONT COLOR="#B22222">// compute distance from c to segment between a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointSegment</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(dist2(c, ProjectPointSegment(a, b, c)));
}

<I><FONT COLOR="#B22222">// compute distance between point (x,y,z) and plane ax+by+cz=d
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointPlane</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y, <B><FONT COLOR="#228B22">double</FONT></B> z,
                          <B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d)
{
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);
}

<I><FONT COLOR="#B22222">// determine if lines from a to b and c to d are parallel or collinear
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesParallel</FONT></B>(PT a, PT b, PT c, PT d) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(cross(b-a, c-d)) &lt; EPS; 
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesCollinear</FONT></B>(PT a, PT b, PT c, PT d) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> LinesParallel(a, b, c, d)
      &amp;&amp; fabs(cross(a-b, a-c)) &lt; EPS
      &amp;&amp; fabs(cross(c-d, c-a)) &lt; EPS; 
}

<I><FONT COLOR="#B22222">// determine if line segment from a to b intersects with 
</FONT></I><I><FONT COLOR="#B22222">// line segment from c to d
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">SegmentsIntersect</FONT></B>(PT a, PT b, PT c, PT d) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (LinesCollinear(a, b, c, d)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS ||
      dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B> (dot(c-a, c-b) &gt; 0 &amp;&amp; dot(d-a, d-b) &gt; 0 &amp;&amp; dot(c-b, d-b) &gt; 0)
      <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (cross(d-a, b-a) * cross(c-a, b-a) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">if</FONT></B> (cross(a-c, d-c) * cross(b-c, d-c) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// compute intersection of line passing through a and b
</FONT></I><I><FONT COLOR="#B22222">// with line passing through c and d, assuming that unique
</FONT></I><I><FONT COLOR="#B22222">// intersection exists; for segment intersection, check if
</FONT></I><I><FONT COLOR="#B22222">// segments intersect first
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeLineIntersection</FONT></B>(PT a, PT b, PT c, PT d) {
  b=b-a; d=c-d; c=c-a;
  assert(dot(b, b) &gt; EPS &amp;&amp; dot(d, d) &gt; EPS);
  <B><FONT COLOR="#A020F0">return</FONT></B> a + b*cross(c, d)/cross(b, d);
}

<I><FONT COLOR="#B22222">// compute center of circle given three points
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeCircleCenter</FONT></B>(PT a, PT b, PT c) {
  b=(a+b)/2;
  c=(a+c)/2;
  <B><FONT COLOR="#A020F0">return</FONT></B> ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));
}

<I><FONT COLOR="#B22222">// determine if point is in a possibly non-convex polygon (by William
</FONT></I><I><FONT COLOR="#B22222">// Randolph Franklin); returns 1 for strictly interior points, 0 for
</FONT></I><I><FONT COLOR="#B22222">// strictly exterior points, and 0 or 1 for the remaining points.
</FONT></I><I><FONT COLOR="#B22222">// Note that it is possible to convert this into an *exact* test using
</FONT></I><I><FONT COLOR="#B22222">// integer arithmetic by taking care of the division appropriately
</FONT></I><I><FONT COLOR="#B22222">// (making sure to deal with signs properly) and then by writing exact
</FONT></I><I><FONT COLOR="#B22222">// tests for checking point on polygon boundary
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointInPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
  <B><FONT COLOR="#228B22">bool</FONT></B> c = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1)%p.size();
    <B><FONT COLOR="#A020F0">if</FONT></B> ((p[i].y &lt;= q.y &amp;&amp; q.y &lt; p[j].y || 
      p[j].y &lt;= q.y &amp;&amp; q.y &lt; p[i].y) &amp;&amp;
      q.x &lt; p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
      c = !c;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> c;
}

<I><FONT COLOR="#B22222">// determine if point is on the boundary of a polygon
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointOnPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) &lt; EPS)
      <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">// compute intersection of line through points a and b with
</FONT></I><I><FONT COLOR="#B22222">// circle centered at c with radius r &gt; 0
</FONT></I>vector&lt;PT&gt; CircleLineIntersection(PT a, PT b, PT c, <B><FONT COLOR="#228B22">double</FONT></B> r) {
  vector&lt;PT&gt; ret;
  b = b-a;
  a = a-c;
  <B><FONT COLOR="#228B22">double</FONT></B> A = dot(b, b);
  <B><FONT COLOR="#228B22">double</FONT></B> B = dot(a, b);
  <B><FONT COLOR="#228B22">double</FONT></B> C = dot(a, a) - r*r;
  <B><FONT COLOR="#228B22">double</FONT></B> D = B*B - A*C;
  <B><FONT COLOR="#A020F0">if</FONT></B> (D &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);
  <B><FONT COLOR="#A020F0">if</FONT></B> (D &gt; EPS)
    ret.push_back(c+a+b*(-B-sqrt(D))/A);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// compute intersection of circle centered at a with radius r
</FONT></I><I><FONT COLOR="#B22222">// with circle centered at b with radius R
</FONT></I>vector&lt;PT&gt; CircleCircleIntersection(PT a, PT b, <B><FONT COLOR="#228B22">double</FONT></B> r, <B><FONT COLOR="#228B22">double</FONT></B> R) {
  vector&lt;PT&gt; ret;
  <B><FONT COLOR="#228B22">double</FONT></B> d = sqrt(dist2(a, b));
  <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; r+R || d+min(r, R) &lt; max(r, R)) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  <B><FONT COLOR="#228B22">double</FONT></B> x = (d*d-R*R+r*r)/(2*d);
  <B><FONT COLOR="#228B22">double</FONT></B> y = sqrt(r*r-x*x);
  PT v = (b-a)/d;
  ret.push_back(a+v*x + RotateCCW90(v)*y);
  <B><FONT COLOR="#A020F0">if</FONT></B> (y &gt; 0)
    ret.push_back(a+v*x - RotateCCW90(v)*y);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// This code computes the area or centroid of a (possibly nonconvex)
</FONT></I><I><FONT COLOR="#B22222">// polygon, assuming that the coordinates are listed in a clockwise or
</FONT></I><I><FONT COLOR="#B22222">// counterclockwise fashion.  Note that the centroid is often known as
</FONT></I><I><FONT COLOR="#B22222">// the &quot;center of gravity&quot; or &quot;center of mass&quot;.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeSignedArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#228B22">double</FONT></B> area = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
    area += p[i].x*p[j].y - p[j].x*p[i].y;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> area / 2.0;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ComputeSignedArea(p));
}

PT <B><FONT COLOR="#0000FF">ComputeCentroid</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  PT c(0,0);
  <B><FONT COLOR="#228B22">double</FONT></B> scale = 6.0 * ComputeSignedArea(p);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> c / scale;
}

<I><FONT COLOR="#B22222">// tests whether or not a given polygon (in CW or CCW order) is simple
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsSimple</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+1; k &lt; p.size(); k++) {
      <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
      <B><FONT COLOR="#228B22">int</FONT></B> l = (k+1) % p.size();
      <B><FONT COLOR="#A020F0">if</FONT></B> (i == l || j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (SegmentsIntersect(p[i], p[j], p[k], p[l])) 
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// Creates a d offseted polygon by given polygon points.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">offsetPolygonArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, <B><FONT COLOR="#228B22">double</FONT></B> D) {
  vector&lt;PT&gt; q;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
      <B><FONT COLOR="#228B22">double</FONT></B> a1 = p[(i+1)%p.size()].y - p[i].y;
      <B><FONT COLOR="#228B22">double</FONT></B> b1 = p[i].x - p[(i+1)%p.size()].x;
      <B><FONT COLOR="#228B22">double</FONT></B> t = sqrt(a1 * a1 + b1 * b1);
      a1 /= t;
      b1 /= t;
      <B><FONT COLOR="#228B22">double</FONT></B> c1 = a1 * p[i].x + b1 * p[i].y + D;

      <B><FONT COLOR="#228B22">double</FONT></B> a2 = p[(i+2)%p.size()].y - p[(i+1)%p.size()].y;
      <B><FONT COLOR="#228B22">double</FONT></B> b2 = p[(i+1)%p.size()].x - p[(i+2)%p.size()].x;
      t = sqrt(a2 * a2 + b2 * b2);
      a2 /= t;
      b2 /= t;
      <B><FONT COLOR="#228B22">double</FONT></B> c2 = a2 * p[(i+1)%p.size()].x + b2 * p[(i+1)%p.size()].y + D;

      <B><FONT COLOR="#228B22">double</FONT></B> det = a1 * b2 - a2 * b1;
      <B><FONT COLOR="#228B22">double</FONT></B> xx = (c1 * b2 - c2 * b1) / det;
      <B><FONT COLOR="#228B22">double</FONT></B> yy = (a1 * c2 - a2 * c1) / det;
      q.pb(PT(xx, yy));
  }
  <I><FONT COLOR="#B22222">//printf(&quot;equals? %d\n&quot;, q.size() == p.size());
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> ComputeArea(q);
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  freopen(<B><FONT COLOR="#BC8F8F">&quot;in.txt&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;r&quot;</FONT></B>, stdin);
  freopen(<B><FONT COLOR="#BC8F8F">&quot;out.txt&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>, stdout);
  <I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>  cerr &lt;&lt; RotateCCW90(PT(2,5)) &lt;&lt; endl;

  <I><FONT COLOR="#B22222">// expected: (5,-2)
</FONT></I>  cerr &lt;&lt; RotateCW90(PT(2,5)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>  cerr &lt;&lt; RotateCCW(PT(2,5),M_PI/2) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: (5,2)
</FONT></I>  cerr &lt;&lt; ProjectPointLine(PT(-5,-2), PT(10,4), PT(3,7)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: (5,2) (7.5,3) (2.5,1)
</FONT></I>  cerr &lt;&lt; ProjectPointSegment(PT(-5,-2), PT(10,4), PT(3,7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; ProjectPointSegment(PT(7.5,3), PT(10,4), PT(3,7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; ProjectPointSegment(PT(-5,-2), PT(2.5,1), PT(3,7)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: 6.78903
</FONT></I>  cerr &lt;&lt; DistancePointPlane(4,-4,3,2,-2,5,-8) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: 1 0 1
</FONT></I>  cerr &lt;&lt; LinesParallel(PT(1,1), PT(3,5), PT(2,1), PT(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; LinesParallel(PT(1,1), PT(3,5), PT(2,0), PT(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; LinesParallel(PT(1,1), PT(3,5), PT(5,9), PT(7,13)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: 0 0 1
</FONT></I>  cerr &lt;&lt; LinesCollinear(PT(1,1), PT(3,5), PT(2,1), PT(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; LinesCollinear(PT(1,1), PT(3,5), PT(2,0), PT(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; LinesCollinear(PT(1,1), PT(3,5), PT(5,9), PT(7,13)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: 1 1 1 0
</FONT></I>  cerr &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(3,1), PT(-1,3)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(4,3), PT(0,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(2,-1), PT(-2,1)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; SegmentsIntersect(PT(0,0), PT(2,4), PT(5,5), PT(1,7)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: (1,2)
</FONT></I>  cerr &lt;&lt; ComputeLineIntersection(PT(0,0), PT(2,4), PT(3,1), PT(-1,3)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: (1,1)
</FONT></I>  cerr &lt;&lt; ComputeCircleCenter(PT(-3,4), PT(6,1), PT(4,5)) &lt;&lt; endl;

  vector&lt;PT&gt; v; 
  v.push_back(PT(0,0));
  v.push_back(PT(5,0));
  v.push_back(PT(5,5));
  v.push_back(PT(0,5));
  
  <I><FONT COLOR="#B22222">// expected: 1 1 1 0 0
</FONT></I>  cerr &lt;&lt; PointInPolygon(v, PT(2,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointInPolygon(v, PT(2,0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointInPolygon(v, PT(0,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointInPolygon(v, PT(5,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointInPolygon(v, PT(2,5)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: 0 1 1 1 1
</FONT></I>  cerr &lt;&lt; PointOnPolygon(v, PT(2,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointOnPolygon(v, PT(2,0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointOnPolygon(v, PT(0,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointOnPolygon(v, PT(5,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
       &lt;&lt; PointOnPolygon(v, PT(2,5)) &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// expected: (1,6)
</FONT></I>  <I><FONT COLOR="#B22222">//           (5,4) (4,5)
</FONT></I>  <I><FONT COLOR="#B22222">//           blank line
</FONT></I>  <I><FONT COLOR="#B22222">//           (4,5) (5,4)
</FONT></I>  <I><FONT COLOR="#B22222">//           blank line
</FONT></I>  <I><FONT COLOR="#B22222">//           (4,5) (5,4)
</FONT></I>  vector&lt;PT&gt; u = CircleLineIntersection(PT(0,6), PT(2,6), PT(1,1), 5);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
  u = CircleLineIntersection(PT(0,9), PT(9,0), PT(1,1), 5);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(10,10), 5, 5);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(8,8), 5, 5);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(4.5,4.5), 10, sqrt(2.0)/2.0);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
  u = CircleCircleIntersection(PT(1,1), PT(4.5,4.5), 5, sqrt(2.0)/2.0);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
  
  <I><FONT COLOR="#B22222">// area should be 5.0
</FONT></I>  <I><FONT COLOR="#B22222">// centroid should be (1.1666666, 1.166666)
</FONT></I>  PT pa[] = { PT(0,0), PT(5,0), PT(1,1), PT(0,5) };
  vector&lt;PT&gt; p(pa, pa+4);
  PT c = ComputeCentroid(p);
  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Area: &quot;</FONT></B> &lt;&lt; ComputeArea(p) &lt;&lt; endl;
  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Centroid: &quot;</FONT></B> &lt;&lt; c &lt;&lt; endl;
  
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<H2><A NAME="file12">Convex hull (C++)</A></H2>
<PRE>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">const</FONT></B> T EPS = 1e-7;
<B><FONT COLOR="#228B22">struct</FONT></B> PT { 
  T x, y; 
  PT() {} 
  PT(T x, T y) : x(x), y(y) {}
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y,x) &lt; make_pair(rhs.y,rhs.x); }
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y,x) == make_pair(rhs.y,rhs.x); }
};
T cross(PT p, PT q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.y-p.y*q.x; }
T area2(PT a, PT b, PT c) { <B><FONT COLOR="#A020F0">return</FONT></B> cross(a,b) + cross(b,c) + cross(c,a); }

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">between</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;b, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> (fabs(area2(a,b,c)) &lt; EPS &amp;&amp; (a.x-b.x)*(c.x-b.x) &lt;= 0 &amp;&amp; (a.y-b.y)*(c.y-b.y) &lt;= 0);
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">ConvexHull</FONT></B>(vector&lt;PT&gt; &amp;pts) {
  sort(pts.begin(), pts.end());
  pts.erase(unique(pts.begin(), pts.end()), pts.end());
  vector&lt;PT&gt; up, dn;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; pts.size(); i++) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (up.size() &gt; 1 &amp;&amp; area2(up[up.size()-2], up.back(), pts[i]) &gt;= 0) up.pop_back();
    <B><FONT COLOR="#A020F0">while</FONT></B> (dn.size() &gt; 1 &amp;&amp; area2(dn[dn.size()-2], dn.back(), pts[i]) &lt;= 0) dn.pop_back();
    up.push_back(pts[i]);
    dn.push_back(pts[i]);
  }
  pts = dn;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = (<B><FONT COLOR="#228B22">int</FONT></B>) up.size() - 2; i &gt;= 1; i--) pts.push_back(up[i]);
  
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (pts.size() &lt;= 2) <B><FONT COLOR="#A020F0">return</FONT></B>;
  dn.clear();
  dn.push_back(pts[0]);
  dn.push_back(pts[1]);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt; pts.size(); i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (between(dn[dn.size()-2], dn[dn.size()-1], pts[i])) dn.pop_back();
    dn.push_back(pts[i]);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (dn.size() &gt;= 3 &amp;&amp; between(dn.back(), dn[0], dn[1])) {
    dn[0] = dn.back();
    dn.pop_back();
  }
  pts = dn;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    vector&lt;PT&gt;pts;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;n);
    <B><FONT COLOR="#A020F0">while</FONT></B> (n--) {
         <B><FONT COLOR="#228B22">double</FONT></B> x, y;
         scanf(<B><FONT COLOR="#BC8F8F">&quot;%lf%lf&quot;</FONT></B>, &amp;x, &amp;y);
         pts.push_back(PT(x, y));
    }
    ConvexHull(pts);
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>)pts.size());
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; pts.size(); i++)
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>)pts[i].x, (<B><FONT COLOR="#228B22">int</FONT></B>)pts[i].y);
}
</PRE>
<HR>
<H2><A NAME="file13">Combination (C++)</A></H2>
<PRE>
<I><FONT COLOR="#B22222">// Combination.
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">mp</FONT> make_pair
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">pb</FONT> push_back
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">lmax</FONT> 2147483647 //32 bit max signed!
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">lmin</FONT> -2147483647 //32 bit min
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">ulmax</FONT> 4294967295 //32 bit unsigned max(2^32 - 1)!
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">mx</FONT> (1&lt;&lt;20)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">md</FONT> 1000000009
<B><FONT COLOR="#228B22">int</FONT></B> f[mx+10]; <I><FONT COLOR="#B22222">// count factorials before use!!
</FONT></I><I><FONT COLOR="#B22222">/* This function calculates (a^b)%MOD */</FONT></I>
<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#0000FF">pow</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> MOD) {
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> x = 1, y = a; 
    <B><FONT COLOR="#A020F0">while</FONT></B> (b &gt; 0) {
        <B><FONT COLOR="#A020F0">if</FONT></B>(b%2 == 1) {
            x = (x*y);
            <B><FONT COLOR="#A020F0">if</FONT></B> (x&gt;MOD) x %= MOD;
        }
        y = (y*y);
        <B><FONT COLOR="#A020F0">if</FONT></B> (y&gt;MOD) y%=MOD; 
        b /= 2;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> x;
}

<I><FONT COLOR="#B22222">/*  Modular Multiplicative Inverse
    Using Euler's Theorem
    a^(phi(m)) = 1 (mod m)
    a^(-1) = a^(m-2) (mod m) */</FONT></I>
<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#0000FF">InverseEuler</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> MOD){
    <B><FONT COLOR="#A020F0">return</FONT></B> pow(n, MOD-2, MOD);
}
 
<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#0000FF">C</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> MOD) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (r &gt; n)
		<B><FONT COLOR="#A020F0">return</FONT></B> 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD;
}
<B><FONT COLOR="#228B22">int</FONT></B> pw[21];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> *argv[]) {
    f[0] = pw[0] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= mx; i++)
    	f[i] = (1ll*f[i-1]*i)%md;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 20; i++)
    	pw[i] = (1&lt;&lt;i);
    <B><FONT COLOR="#228B22">int</FONT></B> k;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;k);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= (1&lt;&lt;k); i++) {
    	<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> a = (1ll*2*C(i-1, pw[k-1]-1, md))%md;
    	<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ff = (1ll*f[pw[k-1]]*f[pw[k-1]])%md;
    	<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> b = ( 1ll*((1ll*a)%md)*ff)%md;
    	cout&lt;&lt;b&lt;&lt;endl;
     }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<H2><A NAME="file14">Gauss jordan (C++)</A></H2>
<PRE>
<I><FONT COLOR="#B22222">// Gauss-Jordan elimination with full pivoting.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Uses:
</FONT></I><I><FONT COLOR="#B22222">//   (1) solving systems of linear equations (AX=B)
</FONT></I><I><FONT COLOR="#B22222">//   (2) inverting matrices (AX=I)
</FONT></I><I><FONT COLOR="#B22222">//   (3) computing determinants of square matrices
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//           b[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   X      = an nxm matrix (stored in b[][])
</FONT></I><I><FONT COLOR="#B22222">//           A^{-1} = an nxn matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns determinant of a[][]
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-10;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

T GaussJordan(VVT &amp;a, VVT &amp;b) {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = b[0].size();
  VI irow(n), icol(n), ipiv(n);
  T det = 1;

  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    <B><FONT COLOR="#228B22">int</FONT></B> pj = -1, pk = -1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[j])
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[k])
	<B><FONT COLOR="#A020F0">if</FONT></B> (pj == -1 || fabs(a[j][k]) &gt; fabs(a[pj][pk])) { pj = j; pk = k; }
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[pj][pk]) &lt; EPS) { cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Matrix is singular.&quot;</FONT></B> &lt;&lt; endl; exit(0); }
    ipiv[pk]++;
    swap(a[pj], a[pk]);
    swap(b[pj], b[pk]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (pj != pk) det *= -1;
    irow[i] = pj;
    icol[i] = pk;

    T c = 1.0 / a[pk][pk];
    det *= a[pk][pk];
    a[pk][pk] = 1.0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) a[pk][p] *= c;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; m; p++) b[pk][p] *= c;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) <B><FONT COLOR="#A020F0">if</FONT></B> (p != pk) {
      c = a[p][pk];
      a[p][pk] = 0;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; n; q++) a[p][q] -= a[pk][q] * c;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; m; q++) b[p][q] -= b[pk][q] * c;      
    }
  }

  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = n-1; p &gt;= 0; p--) <B><FONT COLOR="#A020F0">if</FONT></B> (irow[p] != icol[p]) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) swap(a[k][irow[p]], a[k][icol[p]]);
  }

  <B><FONT COLOR="#A020F0">return</FONT></B> det;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 4;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 2;
  <B><FONT COLOR="#228B22">double</FONT></B> A[n][n] = { {1,2,3,4},{1,0,1,0},{5,3,2,4},{6,1,4,6} };
  <B><FONT COLOR="#228B22">double</FONT></B> B[n][m] = { {1,2},{4,3},{5,6},{8,7} };
  VVT a(n), b(n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    a[i] = VT(A[i], A[i] + n);
    b[i] = VT(B[i], B[i] + m);
  }
  
  <B><FONT COLOR="#228B22">double</FONT></B> det = GaussJordan(a, b);
  
  <I><FONT COLOR="#B22222">// expected: 60  
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Determinant: &quot;</FONT></B> &lt;&lt; det &lt;&lt; endl;

  <I><FONT COLOR="#B22222">// expected: -0.233333 0.166667 0.133333 0.0666667
</FONT></I>  <I><FONT COLOR="#B22222">//           0.166667 0.166667 0.333333 -0.333333
</FONT></I>  <I><FONT COLOR="#B22222">//           0.233333 0.833333 -0.133333 -0.0666667
</FONT></I>  <I><FONT COLOR="#B22222">//           0.05 -0.75 -0.1 0.2
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Inverse: &quot;</FONT></B> &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
      cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
    cout &lt;&lt; endl;
  }
  
  <I><FONT COLOR="#B22222">// expected: 1.63333 1.3
</FONT></I>  <I><FONT COLOR="#B22222">//           -0.166667 0.5
</FONT></I>  <I><FONT COLOR="#B22222">//           2.36667 1.7
</FONT></I>  <I><FONT COLOR="#B22222">//           -1.85 -1.35
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Solution: &quot;</FONT></B> &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++)
      cout &lt;&lt; b[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
    cout &lt;&lt; endl;
  }
}
</PRE>
<HR>
<H2><A NAME="file15">Knut morris pratt (C++)</A></H2>
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">buildTable</FONT></B>(string&amp; w, VI&amp; t)
{
  t = VI(w.length());  
  <B><FONT COLOR="#228B22">int</FONT></B> i = 2, j = 0;
  t[0] = -1; t[1] = 0;
  
  <B><FONT COLOR="#A020F0">while</FONT></B>(i &lt; w.length())
  {
    <B><FONT COLOR="#A020F0">if</FONT></B>(w[i-1] == w[j]) { t[i] = j+1; i++; j++; }
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(j &gt; 0) j = t[j];
    <B><FONT COLOR="#A020F0">else</FONT></B> { t[i] = 0; i++; }
  }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">KMP</FONT></B>(string&amp; s, string&amp; w)
{
  <B><FONT COLOR="#228B22">int</FONT></B> m = 0, i = 0;
  VI t;
  
  buildTable(w, t);  
  <B><FONT COLOR="#A020F0">while</FONT></B>(m+i &lt; s.length())
  {
    <B><FONT COLOR="#A020F0">if</FONT></B>(w[i] == s[m+i])
    {
      i++;
      <B><FONT COLOR="#A020F0">if</FONT></B>(i == w.length()) <B><FONT COLOR="#A020F0">return</FONT></B> m;
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
    {
      m += i-t[i];
      <B><FONT COLOR="#A020F0">if</FONT></B>(i &gt; 0) i = t[i];
    }
  }  
  <B><FONT COLOR="#A020F0">return</FONT></B> s.length();
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>()
{
  string a = (string) <B><FONT COLOR="#BC8F8F">&quot;The example above illustrates the general technique for assembling &quot;</FONT></B>+
    <B><FONT COLOR="#BC8F8F">&quot;the table with a minimum of fuss. The principle is that of the overall search: &quot;</FONT></B>+
    <B><FONT COLOR="#BC8F8F">&quot;most of the work was already done in getting to the current position, so very &quot;</FONT></B>+
    <B><FONT COLOR="#BC8F8F">&quot;little needs to be done in leaving it. The only minor complication is that the &quot;</FONT></B>+
    <B><FONT COLOR="#BC8F8F">&quot;logic which is correct late in the string erroneously gives non-proper &quot;</FONT></B>+
    <B><FONT COLOR="#BC8F8F">&quot;substrings at the beginning. This necessitates some initialization code.&quot;</FONT></B>;
  
  string b = <B><FONT COLOR="#BC8F8F">&quot;table&quot;</FONT></B>;
  
  <B><FONT COLOR="#228B22">int</FONT></B> p = KMP(a, b);
  cout &lt;&lt; p &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; a.substr(p, b.length()) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; b &lt;&lt; endl;
}
</PRE>
<HR>
<H2><A NAME="file16">LIS (C++)</A></H2>
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">STRICTLY_INCREASNG</FONT> 0

VI <B><FONT COLOR="#0000FF">LongestIncreasingSubsequence</FONT></B>(VI v) {
    VPII best;
    VI dad(v.size(), -1);
  
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) {
        #ifdef STRICTLY_INCREASNG
            PII item = make_pair(v[i], 0);
            <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = lower_bound(best.begin(), best.end(), item);
            item.second = i;
        #<B><FONT COLOR="#A020F0">else</FONT></B>
            PII item = make_pair(v[i], i);
            <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = upper_bound(best.begin(), best.end(), item);
        #endif
        <B><FONT COLOR="#A020F0">if</FONT></B> (it == best.end()) {
            dad[i] = (best.size() == 0 ? -1 : best.back().second);
            best.push_back(item);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            dad[i] = dad[it-&gt;second];
            *it = item;
        }
    }
  
    VI ret;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = best.back().second; i &gt;= 0; i = dad[i])
        ret.push_back(v[i]);
    reverse(ret.begin(), ret.end());
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    freopen(<B><FONT COLOR="#BC8F8F">&quot;in.txt&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;r&quot;</FONT></B>, stdin);
    freopen(<B><FONT COLOR="#BC8F8F">&quot;out.txt&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>, stdout);
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    VI v;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;n);
    <B><FONT COLOR="#A020F0">while</FONT></B> (n--) {
      <B><FONT COLOR="#228B22">int</FONT></B> k;
      scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;k);
      v.push_back(k);
    }
    VI ret = LongestIncreasingSubsequence(v);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ret.size(); i++)
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, ret[i]);
}
</PRE>
<HR>
<H2><A NAME="file17">Suffix array (C++)</A></H2>
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> prefix_cmp {
	size_t prefix_len;
	size_t *rank;
	size_t n;
	<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>() (size_t i, size_t j) {
		<B><FONT COLOR="#A020F0">if</FONT></B>( rank[i] != rank[j] ) <B><FONT COLOR="#A020F0">return</FONT></B> rank[i] &lt; rank[j];
		i += prefix_len; j += prefix_len;
		<B><FONT COLOR="#A020F0">if</FONT></B>( i &lt; n &amp;&amp; j &lt; n ) <B><FONT COLOR="#A020F0">return</FONT></B> rank[i] &lt; rank[j];
		<B><FONT COLOR="#A020F0">else</FONT></B>                 <B><FONT COLOR="#A020F0">return</FONT></B> i &gt; j;
	}
};

<I><FONT COLOR="#B22222">// given `string' of length `n', construct the suffix array in SA
</FONT></I><I><FONT COLOR="#B22222">// (SA assumed to have size &gt;= n)
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">suffix_array</FONT></B>( size_t *string, size_t *SA, size_t n ) {
	size_t * rank[2]; rank[0] = <B><FONT COLOR="#A020F0">new</FONT></B> size_t[n]; rank[1] = <B><FONT COLOR="#A020F0">new</FONT></B> size_t[n];
	<B><FONT COLOR="#A020F0">for</FONT></B>( size_t i = 0; i &lt; n; ++i ) { SA[i] = i; rank[0][i] = string[i]; }
	prefix_cmp cmp; cmp.n = n; cmp.prefix_len = 1;
	<B><FONT COLOR="#A020F0">for</FONT></B>( size_t x = 0;; ) {
		cmp.rank = rank[x];
		sort( SA, SA+n, cmp );
		x ^= 1;
		rank[x][SA[0]] = 0;
		<B><FONT COLOR="#A020F0">for</FONT></B>( size_t i = 0; i &lt; n-1; ++i ) {
			rank[x][ SA[i+1] ] = rank[x][ SA[i] ];
			<B><FONT COLOR="#A020F0">if</FONT></B>( cmp(SA[i], SA[i+1]) ) ++rank[x][ SA[i+1] ];
		}
		cmp.prefix_len *= 2;
		<B><FONT COLOR="#A020F0">if</FONT></B>( rank[x][ SA[n-1] ] == n-1 ) <B><FONT COLOR="#A020F0">break</FONT></B>;
	}
	<B><FONT COLOR="#A020F0">delete</FONT></B>[] rank[0]; <B><FONT COLOR="#A020F0">delete</FONT></B>[] rank[1];
}
</PRE>
</BODY></HTML>
